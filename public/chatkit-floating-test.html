<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ChatKit Floating Test</title>
    <style>
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
        background: #f8fafc;
        color: #003769;
        min-height: 100vh;
      }
      .content {
        max-width: 720px;
        margin: 40px auto;
        padding: 0 16px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 1.25rem;
      }
      p {
        margin: 0 0 16px;
        color: #475569;
      }
      /* Bottom-right floating container for the chat widget */
      #chat-wrapper {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 470px;  /* desktop size */
        height: 821px; /* desktop size */
        z-index: 10000;
        display: none;
        display: none;
        /* Layout so footer can sit below the widget */
        display: none;
      }
      #chat-wrapper.open { display: block; }

      /* Make wrapper a column container when open */
      #chat-wrapper.open { display: flex; flex-direction: column; }

      /* Top-right launcher link */
      #chat-launcher {
        position: fixed;
        top: 14px;
        right: 18px;
        background: transparent;
        color: #0f172a;
        font-weight: 700;
        text-decoration: underline;
        cursor: pointer;
        z-index: 10002;
      }
      #chat-wrapper > .chat-header {
        flex: 0 0 auto;
        background: #003769;
        border: 1px solid #003769;
        border-bottom: none;
        border-radius: 12px 12px 0 0;
        padding: 6px 10px;
        font-weight: 600;
        color: #ffffff;
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 5px;
      }
      #chat-wrapper > openai-chatkit {
        flex: 1 1 auto;
        width: 100%;
        height: auto;
        background: #ffffff;
        border-radius: 0 0 12px 12px; /* mates with header above */
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.18);
      }

      /* Collapsible panel helpers */
      .panel-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        background: transparent;
        border: 0;
        color: #64748b;
        padding: 6px 0 2px 0;
        cursor: pointer;
      }
      .panel-toggle svg { transition: transform 0.15s ease; }
      .panel-toggle[aria-expanded="true"] svg { transform: rotate(180deg); }
      #chat-prefill-footer.collapsed .prefill-list { display: none; }
      #capture-panel.collapsed > :not(.panel-toggle) { display: none; }

      /* Unified small action buttons */
      .ck-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 34px;
        height: 34px;
        padding: 0;
        border: 1px solid #cbd5e1; /* slate-300 */
        border-radius: 8px;
        background: #f8fafc;
        cursor: pointer;
        color: #003769;
        font: inherit;
        line-height: 1;
      }
      .ck-btn:disabled {
        opacity: 0.6;
        cursor: default;
        background: #f3f4f6; /* slate-100 */
        color: #94a3b8; /* slate-400 */
      }
      .ck-btn svg { width: 22px; height: 22px; }
      .ck-btn span { display: none; }

      /* Prefill footer sits below the widget inside wrapper */
      #chat-prefill-footer {
        margin-top: 0;
        background: #ffffff;
        border-radius: 10px;
        border-top-left-radius: 0; /* flush with widget above */
        border-top-right-radius: 0; /* flush with widget above */
        border: 1px solid #e2e8f0; /* slate-200 */
        border-top: none; /* remove seam */
        padding: 6px; /* p-1.5 */
        font-family: inherit; /* match chat typeface */
        font-size: 16px; /* align with chat body text */
        line-height: 1.5;
      }
      #chat-prefill-footer * { font-family: inherit; }
      #chat-prefill-footer .prefill-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        gap: 12px;
        padding: 8px 12px;
        border-radius: 8px;
        background: #ffffff;
        border: 1px solid transparent;
        color: #0f172ac4;
        cursor: pointer;
      }
      #chat-prefill-footer .prefill-item:hover { background: #f1f5f9; }
      #chat-prefill-footer .prefill-left { display: flex; align-items: center; gap: 12px; min-width: 0; }
      #chat-prefill-footer .prefill-icon {
        width: 24px; height: 24px; display: inline-flex; align-items: center; justify-content: center;
        border-radius: 9999px; background: #f1f5f9; color: #0f172ac4;
      }
      #chat-prefill-footer .prefill-label { font-size: 16px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      #chat-prefill-footer .prefill-disclaimer { text-align: center; font-size: 12px; color: #64748b; margin-top: 6px; }
      #chat-prefill-footer .prefill-disclaimer a { color: inherit; text-decoration: underline; }
      /* No native prompts; custom prefill footer below composer */

      /* (minimize now uses native header rightAction, no overlay) */

      @media (max-width: 480px) {
        #chat-wrapper {
          width: calc((100vw - 24px) * 1.21);
          height: 73vh;
          left: 12px;
          right: 12px;
          bottom: 12px;
        }
        
      }
    </style>
    <!-- Load the ChatKit web component -->
    <script
      src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js"
      async
    ></script>
  </head>
  <body>
    <div class="content">
      <h1>ChatKit Floating Test</h1>
      <p>
        Make sure your server is running with <code>OPENAI_API_KEY</code>      </p>
    </div>

    <a id="chat-launcher" href="#" aria-controls="chat-wrapper" aria-expanded="false">Support Request</a>
    <div id="chat-wrapper"></div>

    <script>
      function getUrlParam(name) {
        const url = new URL(window.location.href);
        const v = url.searchParams.get(name);
        return v ? v.trim() : null;
      }
      function getCaseInsensitiveParam(...candidates) {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        const keys = Array.from(params.keys());
        for (const cand of candidates) {
          const found = keys.find((k) => k.toLowerCase() === String(cand).toLowerCase());
          if (found) {
            const v = params.get(found);
            if (v) { return v.trim(); }
          }
        }
        return null;
      }

      // Seed global user from URL and broadcast for listeners (hosted app/iframe patterns)
      (function seedUserFromUrl(){
        const firstName = getCaseInsensitiveParam('firstname','first','firstName');
        const lastName  = getCaseInsensitiveParam('lastname','last','lastName');
        const email     = getCaseInsensitiveParam('email','mail','eMail','Email');
        const fyiUser = { firstName: firstName || '', lastName: lastName || '', email: email || '' };
        window.fyiUser = fyiUser;
        try { window.dispatchEvent(new CustomEvent('fyi-user', { detail: fyiUser })); } catch(_) {}
      })();

      async function getClientSecret(currentSecret) {
        // Always mint on our server; ChatKit may call this again to refresh.
        const response = await fetch('/api/create-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        if (!response.ok) {
          const text = await response.text().catch(() => '');
          throw new Error('Failed to create ChatKit session: ' + (text || response.statusText));
        }
        const data = await response.json();
        try { window.appSessionId = data.app_session_id || null; } catch (_) {}
        if (!data || !data.client_secret) {
          throw new Error('Missing client_secret in response');
        }
        return data.client_secret;
      }

      // Wait until the custom element is defined, then create and initialize it.
      (async function initWhenReady() {
        if (!(window.customElements && window.customElements.get('openai-chatkit'))) {
          requestAnimationFrame(initWhenReady);
          return;
        }

        try {
          const wrapper = document.getElementById('chat-wrapper');
          const launcher = document.getElementById('chat-launcher');
          // Header
          const header = document.createElement('div');
          header.className = 'chat-header';
          const logo = document.createElement('img');
          logo.src = '/fyi-green-envelop-arrow.png';
          logo.alt = 'logo';
          logo.width = 45; // 10% smaller
          logo.height = 61;
          logo.style.objectFit = 'contain';
          logo.style.display = 'block';
          const title = document.createElement('span');
          title.textContent = 'fyi assistant';
          header.appendChild(logo);
          header.appendChild(title);

          const el = document.createElement('openai-chatkit');
          // Compute UI greeting from URL user if present
          const firstForGreeting = getCaseInsensitiveParam('firstname','first','firstName');
          const uiGreeting = firstForGreeting ? `Hi ${firstForGreeting}, how can I help?` : 'How can I help you today?';
          // no blurb in greeting; keep greeting concise
          // Provide a token fetcher; ChatKit will call this as needed.
          el.setOptions({
            api: { getClientSecret },
            theme: {
              color: {
                accent: { primary: '#4ccf96', level: 3 },
              }
            },
            // no client tools currently
            header: {
              title: 'fyi assistantant'
            },
            header: {
              rightAction: {
                icon: 'collapse-small',
                onClick: () => {
                  wrapper.classList.remove('open');
                  launcher.setAttribute('aria-expanded', 'false');
                }
              }
            },
            startScreen: {
              greeting: uiGreeting,
              prompts: [
                { label: 'What can fyi do for me?', prompt: 'What can fyi do for me?', icon: 'sparkle' },
                { label: 'Tell me about the subscription plans', prompt: 'Tell me about the subscription plans', icon: 'circle-question' },
                { label: "What's new with fyi?", prompt: "What's the latest with fyi?", icon: 'sparkle' }
              ]
            },
            disclaimer: {
              text: 'AI can make mistakes — See [ Help articles ](https://support.fyi.app/)'
            },
            composer: {
              placeholder: 'Message the assistant',
              attachments: {
                enabled: false,
                accept: {
                  "image/*": [".png", ".jpg", ".jpeg", ".gif", ".webp"],
                  "application/pdf": [".pdf"]
                }
              }
            },
            // Make source items clickable when they include a usable URL.
            entities: {
              onClick: (entity) => {
                let url = (entity.data && entity.data.url) || (typeof entity.title === 'string' && entity.title.match(/^https?:\/\//) ? entity.title : null);
                // Fallback: derive FYI support article link from filename-like titles
                if (!url && typeof entity.title === 'string') {
                  const t = entity.title.trim();
                  // Match: 4404600478605-Support-Requests-and-... .html
                  const m = t.match(/^(\d{6,})-([A-Za-z0-9\-]+)\.html$/);
                  if (m) {
                    url = `https://support.fyi.app/hc/en-us/articles/${m[1]}-${m[2]}.html`;
                  }
                }
                if (url) {
                  try { window.open(url, '_blank', 'noopener,noreferrer'); } catch (_) {}
                }
              }
            },
            widgets: {
              onAction: async (action) => {
                try {
                  if (action?.type === 'prefill' && action?.payload?.text) {
                    await el.setComposerValue({ text: String(action.payload.text) });
                    await el.focusComposer();
                    return;
                  }
                  if (action?.type === 'start_recording' || action?.type === 'screen_record') {
                    await startRecording();
                    return;
                  }
                  if (action?.type === 'stop_recording') {
                    stopRecording();
                    return;
                  }
                  if (action?.type === 'screenshot') {
                    await takeScreenshot();
                    return;
                  }
                  if (action?.type === 'attach') {
                    const input = document.getElementById('ck-file-input');
                    if (input && typeof input.click === 'function') {
                      input.click();
                    }
                    return;
                  }
                  const url = (action && (action.payload?.url || action.payload?.href)) || null;
                  if (url && /^https?:\/\//.test(String(url))) {
                    try { window.open(String(url), '_blank', 'noopener,noreferrer'); } catch (_) {}
                  }
                } catch (_) {}
              }
            }
          });
          wrapper.appendChild(header);
          wrapper.appendChild(el);

          // Collapse agent thinking content to header-only inside the web component
          (function initThinkingCollapse(){
            const scrollToBottom = (root) => {
              try {
                const els = Array.from(root.querySelectorAll('*'));
                for (const n of els) {
                  const cs = getComputedStyle(n);
                  if ((cs.overflowY === 'auto' || cs.overflowY === 'scroll') && n.scrollHeight > n.clientHeight) {
                    n.scrollTop = n.scrollHeight;
                  }
                }
              } catch {}
            };

            const collapse = () => {
              try {
                const root = el.shadowRoot;
                if (!root) return;
                // 1) Attribute-based match (when available)
                const attrCandidates = root.querySelectorAll('[data-kind="thinking"], [data-message-type="thinking"], [part*="thinking"]');
                attrCandidates.forEach((n) => {
                  try {
                    if (n.style && (n.style.position === 'sticky' || n.style.position === 'fixed')) { n.style.position = 'static'; n.style.top = ''; n.style.bottom = ''; }
                    const kids = Array.from(n.children);
                    kids.forEach((k, idx) => { if (idx > 0 && k && k.style) { k.style.display = 'none'; } });
                  } catch {}
                });

                // 2) Text-based match (fallback for current builds)
                const all = root.querySelectorAll('*');
                all.forEach((elNode) => {
                  try {
                    const txt = (elNode.textContent || '').trim();
                    if (!txt || (!txt.startsWith('Thought for a moment') && !/^Thinking\b/i.test(txt))) return;
                    // Find a reasonable container (message wrapper)
                    const container = elNode.closest('[data-message-id], [data-kind], article, li, section, div') || elNode.parentElement;
                    if (!container) return;
                    // neutralize sticky on the wrapper to restore auto-scroll
                    const cs = getComputedStyle(container);
                    if (cs.position === 'sticky' || cs.position === 'fixed') {
                      container.style.position = 'static';
                      container.style.top = '';
                      container.style.bottom = '';
                    }
                    container.style.maxHeight = 'none';
                    container.style.overflow = 'visible';
                    // Hide all descendants except the header node
                    const descendants = container.querySelectorAll('*');
                    descendants.forEach((d) => { if (d !== elNode && !d.contains(elNode) && d.style) d.style.display = 'none'; });
                  } catch {}
                });
                // ensure scroll sticks to bottom after modifications
                scrollToBottom(root);
              } catch {}
            };

            const tryObserve = () => {
              try {
                const root = el.shadowRoot;
                if (!root) { requestAnimationFrame(tryObserve); return; }
                collapse();
                const mo = new MutationObserver(() => collapse());
                mo.observe(root, { childList: true, subtree: true });
              } catch {}
            };
            tryObserve();
          })();

          // Prefill footer (under composer area)
          const footer = document.createElement('div');
          footer.id = 'chat-prefill-footer';
          const list = document.createElement('div');
          list.className = 'prefill-list';
          const prompts = [
            ['Enhancement request', 'I want to request this product enhancement: '],
            ['Report an issue', 'I want to report the following issue: '],
            ['I need help with…', 'I need help with: '],
          ];
          const iconSvgs = {
            sparkle: '<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path d="M9.5 1.75a.75.75 0 0 1 1 0l1.8 1.64c.2.18.31.43.31.7 0 .27-.11.52-.31.7L10.5 6.43a.75.75 0 0 1-1 0L7.7 4.79a.98.98 0 0 1-.31-.7c0-.27.11-.52.31-.7L9.5 1.75zM3.2 9.2a.6.6 0 0 1 .8 0l1.28 1.16c.18.16.28.38.28.62s-.1.46-.28.62L4 12.76a.6.6 0 0 1-.8 0l-1.28-1.16A.86.86 0 0 1 1.64 11c0-.24.1-.46.28-.62L3.2 9.2zm13.6 0a.6.6 0 0 1 .8 0l1.28 1.16c.18.16.28.38.28.62s-.1.46-.28.62L17.6 12.76a.6.6 0 0 1-.8 0l-1.28-1.16a.86.86 0 0 1-.28-.62c0-.24.1-.46.28-.62L16.8 9.2zM8.5 8.75a1 1 0 0 1 3 0l.41 1.25c.14.44.5.8.94.94L14.1 11a1 1 0 0 1 0 2l-1.25.41a1.5 1.5 0 0 0-.94.94L11.5 15a1 1 0 0 1-3 0l-.41-1.25a1.5 1.5 0 0 0-.94-.94L5.9 13a1 1 0 0 1 0-2l1.25-.41c.44-.14.8-.5.94-.94L8.5 8.75z"/></svg>',
            bug: '<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path d="M10 2a2 2 0 0 1 2 2v1h1a2 2 0 0 1 2 2v1h-2V7H7v1H5V7a2 2 0 0 1 2-2h1V4a2 2 0 0 1 2-2zM4 10h12v4a4 4 0 0 1-4 4H8a4 4 0 0 1-4-4v-4z"/></svg>',
            lifesaver: '<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path d="M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16zm0 3a5 5 0 1 1 0 10A5 5 0 0 1 10 5z"/></svg>'
          };
          const rightSvg = '<svg viewBox="0 0 20 20" width="16" height="16" fill="currentColor"><path d="M7.25 5.25a.75.75 0 0 1 1.06 0l4 4a.75.75 0 0 1 0 1.06l-4 4a.75.75 0 1 1-1.06-1.06L10.94 10 7.25 6.31a.75.75 0 0 1 0-1.06z"/></svg>';
          const icons = ['sparkle','bug','lifesaver'];
          prompts.forEach(([label, text], idx) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'prefill-item';
            btn.innerHTML = `<span class="prefill-left"><span class="prefill-icon">${iconSvgs[icons[idx] || 'sparkle']}</span><span class="prefill-label">${label}</span></span>${rightSvg}`;
            btn.addEventListener('click', async () => {
              try { await el.setComposerValue({ text }); await el.focusComposer(); } catch (_) {}
            });
            list.appendChild(btn);
          });
          footer.appendChild(list);
          // Toggle button
          const prefillToggle = document.createElement('button');
          prefillToggle.type = 'button';
          prefillToggle.className = 'panel-toggle';
          prefillToggle.setAttribute('aria-expanded', 'true');
          prefillToggle.innerHTML = '<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor" aria-hidden="true"><path d="M5.23 7.21a.75.75 0 0 1 1.06.02L10 10.06l3.71-2.83a.75.75 0 0 1 .92 1.18l-4.17 3.18a.75.75 0 0 1-.92 0L5.25 8.41a.75.75 0 0 1-.02-1.2z"/></svg>';
          prefillToggle.addEventListener('click', () => {
            const isOpen = prefillToggle.getAttribute('aria-expanded') === 'true';
            prefillToggle.setAttribute('aria-expanded', String(!isOpen));
            footer.classList.toggle('collapsed', isOpen);
          });
          footer.appendChild(prefillToggle);
          // Disclaimer is shown by ChatKit; avoid duplicating it in the footer
          wrapper.appendChild(footer);

          // Capture panel (screen recording and screenshot tools)
          const capture = document.createElement('div');
          capture.id = 'capture-panel';
          capture.style.marginTop = '8px';
          capture.style.background = '#ffffff';
          capture.style.border = '1px solid #e2e8f0';
          capture.style.borderRadius = '10px';
          capture.style.padding = '8px';
          capture.innerHTML = `
            <div id="ck-cap-body">
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <button id="ck-start-recording" type="button" class="ck-btn" title="Start recording">
                <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M12 6a2 2 0 0 1 2 2v.586l2.707-2.707A1 1 0 0 1 18 6v8a1 1 0 0 1-1.707.707L14 12.586V13a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h8z"/></svg>
              </button>
              <button id="ck-stop-recording" type="button" class="ck-btn" title="Stop" disabled>
                <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M5 5h10v10H5z"/></svg>
              </button>
              <button id="ck-screenshot" type="button" class="ck-btn" title="Screenshot">
                <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M6 6h2l1-2h2l1 2h2a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2zm4 2a3 3 0 1 0 0 6 3 3 0 0 0 0-6z"/></svg>
              </button>
              <label for="ck-file-input" class="ck-btn" style="user-select:none;" title="Attach file">
                <svg viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M7.5 13.5a2.5 2.5 0 0 1 0-3.536l4.95-4.95a2.5 2.5 0 1 1 3.536 3.536l-1.768 1.768-.707-.707 1.768-1.768a1.5 1.5 0 1 0-2.122-2.122l-4.95 4.95a1.5 1.5 0 0 0 2.122 2.122l1.768-1.768.707.707-1.768 1.768a2.5 2.5 0 0 1-3.536 0z"/></svg>
              </label>
              <input id="ck-file-input" type="file" style="display:none" />
              <span id="ck-recording-indicator" style="display:none; align-items:center; gap:6px; color:#ef4444; font-weight:600;">
                <span style="width:8px; height:8px; background:#ef4444; border-radius:9999px; display:inline-block;"></span>
                Recording...
                <span id="ck-timer" style="color:#64748b; font-weight:500; margin-left:6px;">0:00</span>
              </span>
            </div>
            <div id="ck-upload-progress" style="display:none; margin-top:6px;">
              <div style="height:6px; background:#e5e7eb; border-radius:9999px; overflow:hidden;">
                <div id="ck-upload-bar" style="width:0%; height:6px; background:#4ccf96;"></div>
              </div>
              <div id="ck-upload-text" style="font-size:12px; color:#64748b; margin-top:4px;">0%</div>
            </div>
            <div id="ck-video-url" style="display:none; margin-top:6px; font-size:12px; color:#334155;"></div>
            <div id="ck-video-preview-wrap" style="display:none; margin-top:8px;">
              <video id="ck-video" controls style="width:100%; max-height:360px; background:#000;"></video>
              <div id="ck-video-download" style="margin-top:8px;"></div>
            </div>
            <div id="ck-shot-url" style="display:none; margin-top:6px; font-size:12px; color:#334155;"></div>
            <div id="ck-shot-preview-wrap" style="display:none; margin-top:8px;">
              <img id="ck-shot" alt="Screenshot" style="max-width:100%; border:1px solid #e2e8f0;" />
              <div id="ck-shot-download" style="margin-top:8px;"></div>
            </div>
            <div id="ck-upload-result" style="display:none; margin-top:6px; font-size:12px; color:#334155;"></div>
            </div>
          `;
          // Add toggle control to capture panel footer
          const capToggle = document.createElement('button');
          capToggle.type = 'button';
          capToggle.className = 'panel-toggle';
          capToggle.setAttribute('aria-expanded', 'true');
          capToggle.innerHTML = '<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor" aria-hidden="true"><path d="M5.23 7.21a.75.75 0 0 1 1.06.02L10 10.06l3.71-2.83a.75.75 0 0 1 .92 1.18l-4.17 3.18a.75.75 0 0 1-.92 0L5.25 8.41a.75.75 0 0 1-.02-1.2z"/></svg>';
          capToggle.addEventListener('click', () => {
            const isOpen = capToggle.getAttribute('aria-expanded') === 'true';
            capToggle.setAttribute('aria-expanded', String(!isOpen));
            // Toggle the body wrapper only, preserve controls and layout
            const body = document.getElementById('ck-cap-body');
            if (body) { body.style.display = isOpen ? 'none' : ''; }
          });
          capture.appendChild(capToggle);
          wrapper.appendChild(capture);

          // Using prefill-only behavior in the app. No custom overlay toolbar here.

          let initKickoffSent = false;
          function openChat() {
            wrapper.classList.add('open');
            launcher.setAttribute('aria-expanded', 'true');
            // Focus composer after opening
            setTimeout(() => {
              try { el.focusComposer(); } catch (_) {}
              // Kickoff: ask agent to show prefill options widget on first open
              if (!initKickoffSent) {
                initKickoffSent = true;
              // On first open, send one custom action to pass URL state
              (function scheduleStateSend(){
                const sendOnce = async () => {
                  try {
                    if (scheduleStateSend._sent) return; scheduleStateSend._sent = true;
                    const firstname = getCaseInsensitiveParam('firstname','first','firstName');
                    const lastname = getCaseInsensitiveParam('lastname','last','lastName');
                    const email = getCaseInsensitiveParam('email','eMail','Email');
                    const state = {};
                    if (firstname) state.firstname = firstname;
                    if (lastname) state.lastname = lastname;
                    if (email) state.email = email;
                    if (Object.keys(state).length > 0 && el?.sendCustomAction) {
                      await el.sendCustomAction({ type: 'set_state', payload: state });
                    }
                  } catch (_) {}
                };
                // Try after a small delay to avoid init loops
                setTimeout(sendOnce, 800);
                // Also try on focus to ensure element is ready
                el.addEventListener?.('focus', () => { void sendOnce(); }, { once: true });
              })();
              }
            }, 0);
          }

          function closeChat() {
            wrapper.classList.remove('open');
            launcher.setAttribute('aria-expanded', 'false');
          }

          // Launcher click toggles chat visibility
          launcher.addEventListener('click', (e) => {
            e.preventDefault();
            if (wrapper.classList.contains('open')) {
              closeChat();
            } else {
              openChat();
            }
          });

          // No prompt bar; nothing to bind here.

          // --- Capture helpers ---
          let mediaRecorder = null;
          let recordedChunks = [];
          let recordTimer = 0;
          let timerId = null;

          const $ = (id) => document.getElementById(id);
          const btnStart = $('ck-start-recording');
          const btnStop = $('ck-stop-recording');
          const btnShot = $('ck-screenshot');
          const fileInput = $('ck-file-input');
          const indicator = $('ck-recording-indicator');
          const timer = $('ck-timer');
          const videoEl = $('ck-video');
          const videoWrap = $('ck-video-preview-wrap');
          const videoDownload = $('ck-video-download');
          const videoUrlEl = $('ck-video-url');
          const shotImg = $('ck-shot');
          const shotWrap = $('ck-shot-preview-wrap');
          const shotDownload = $('ck-shot-download');
          const shotUrlEl = $('ck-shot-url');
          const uploadResult = $('ck-upload-result');
          const uploadProgress = $('ck-upload-progress');
          const uploadBar = $('ck-upload-bar');
          const uploadText = $('ck-upload-text');

          function formatTime(totalSeconds) {
            const m = Math.floor(totalSeconds / 60);
            const s = totalSeconds % 60;
            return `${m}:${String(s).padStart(2, '0')}`;
          }

          async function startRecording() {
            try {
              videoUrlEl.style.display = 'block';
              videoUrlEl.textContent = `Page: ${window.location.href}`;
              videoWrap.style.display = 'none';
              videoDownload.innerHTML = '';

              const screenStream = await navigator.mediaDevices.getDisplayMedia({
                video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
                audio: false
              });
              const audioStream = await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: true, noiseSuppression: true },
                video: false
              });
              const combined = new MediaStream([
                ...screenStream.getVideoTracks(),
                ...audioStream.getAudioTracks(),
              ]);

              const mimeTypes = [
                'video/webm;codecs=vp9,opus',
                'video/webm;codecs=vp8,opus',
                'video/webm;codecs=h264,opus',
                'video/webm'
              ];
              const selected = mimeTypes.find((t) => MediaRecorder.isTypeSupported(t)) || 'video/webm';
              mediaRecorder = new MediaRecorder(combined, {
                mimeType: selected,
                audioBitsPerSecond: 128000,
                videoBitsPerSecond: 2500000,
              });

              recordedChunks = [];
              mediaRecorder.ondataavailable = (e) => { if (e.data?.size > 0) recordedChunks.push(e.data); };
              mediaRecorder.onstop = async () => {
                clearInterval(timerId); timerId = null; recordTimer = 0; timer.textContent = '0:00';
                indicator.style.display = 'none';
                const blob = new Blob(recordedChunks, { type: selected });
                const url = URL.createObjectURL(blob);
                videoEl.src = url; videoWrap.style.display = 'block';
                const a = document.createElement('a');
                a.href = url; a.download = 'screen-recording.webm'; a.textContent = '⬇️ Download recording';
                a.style.cssText = 'display:inline-block;padding:8px 12px;background:#2563eb;color:#fff;border-radius:8px;text-decoration:none;';
                videoDownload.innerHTML = '';
                videoDownload.appendChild(a);
                try { await el.sendCustomAction({ type: 'capture_event', payload: { kind: 'recording', status: 'stopped', url, page: window.location.href } }); } catch {}
                try { combined.getTracks().forEach(t => t.stop()); } catch {}
              };

              mediaRecorder.start(1000);
              indicator.style.display = 'inline-flex';
              btnStart.disabled = true; btnStop.disabled = false;
              recordTimer = 0; timer.textContent = '0:00';
              timerId = setInterval(() => { recordTimer += 1; timer.textContent = formatTime(recordTimer); }, 1000);
              try { await el.sendCustomAction({ type: 'capture_event', payload: { kind: 'recording', status: 'started', page: window.location.href } }); } catch {}
            } catch (err) {
              alert('Unable to start recording: ' + (err?.message || err));
            }
          }

          function stopRecording() {
            try { mediaRecorder?.stop(); } catch {}
            btnStart.disabled = false; btnStop.disabled = true;
          }

          async function takeScreenshot() {
            try {
              shotUrlEl.style.display = 'block';
              shotUrlEl.textContent = `Page: ${window.location.href}`;
              shotWrap.style.display = 'none';
              shotDownload.innerHTML = '';

              const stream = await navigator.mediaDevices.getDisplayMedia({
                video: { width: { ideal: 1920 }, height: { ideal: 1080 } },
              });
              const video = document.createElement('video');
              video.srcObject = stream; await video.play();
              await new Promise((r) => setTimeout(r, 100));
              const canvas = document.createElement('canvas');
              canvas.width = video.videoWidth; canvas.height = video.videoHeight;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0);
              try { stream.getTracks().forEach(t => t.stop()); } catch {}
              const blob = await new Promise((res) => canvas.toBlob((b) => res(b), 'image/png'));
              const url = URL.createObjectURL(blob);
              shotImg.src = url; shotWrap.style.display = 'block';
              // Replace with Upload button (to S3 via presign)
              const uploadBtn = document.createElement('button');
              uploadBtn.type = 'button';
              uploadBtn.textContent = '⬆️ Upload screenshot';
              uploadBtn.style.cssText = 'display:inline-block;padding:8px 12px;background:#2563eb;color:#fff;border-radius:8px;border:none;cursor:pointer;';
              shotDownload.innerHTML = '';
              shotDownload.appendChild(uploadBtn);
              uploadBtn.addEventListener('click', async () => {
                try {
                  const appSessionId = window.appSessionId || null;
                  if (!appSessionId) { alert('Missing session id'); return; }
                  const presignRes = await fetch('/api/attachments/presign', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ appSessionId, filename: 'screenshot.png', mime: 'image/png', size: blob.size })
                  });
                  const presign = await presignRes.json();
                  if (!presignRes.ok) throw new Error(presign?.error || 'presign failed');
                  await fetch(presign.url, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'image/png', 'x-amz-server-side-encryption': 'AES256' },
                    body: blob
                  });
                  uploadBtn.textContent = '✅ Uploaded';
                  try { await el.sendCustomAction({ type: 'capture_event', payload: { kind: 'screenshot', status: 'uploaded', key: presign.key, page: window.location.href } }); } catch {}
                } catch (err) {
                  alert('Upload failed: ' + (err?.message || err));
                }
              });
            } catch (err) {
              alert('Unable to capture screenshot: ' + (err?.message || err));
            }
          }

          // Wire local buttons
          if (btnStart) btnStart.addEventListener('click', startRecording);
          if (btnStop) btnStop.addEventListener('click', stopRecording);
          if (btnShot) btnShot.addEventListener('click', takeScreenshot);
          if (fileInput) fileInput.addEventListener('change', async (e) => {
            try {
              const f = (e.target && e.target.files && e.target.files[0]) || null;
              if (!f) return;
              const appSessionId = window.appSessionId || null;
              if (!appSessionId) {
                alert('Upload unavailable: missing session id');
                return;
              }
              const presignRes = await fetch('/api/attachments/presign', {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ appSessionId, filename: f.name, mime: f.type || 'application/octet-stream', size: f.size })
              });
              const presign = await presignRes.json();
              if (!presignRes.ok) throw new Error(presign?.error || 'presign failed');
              // Show progress bar and upload via XHR to get progress events
              uploadResult.style.display = 'none';
              uploadProgress.style.display = 'block';
              uploadBar.style.width = '0%';
              uploadText.textContent = '0%';

              await new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open('PUT', presign.url, true);
                xhr.setRequestHeader('Content-Type', f.type || 'application/octet-stream');
                xhr.setRequestHeader('x-amz-server-side-encryption', 'AES256');
                xhr.upload.onprogress = (ev) => {
                  if (ev.lengthComputable) {
                    const pct = Math.max(0, Math.min(100, Math.round((ev.loaded / ev.total) * 100)));
                    uploadBar.style.width = pct + '%';
                    uploadText.textContent = pct + '%';
                  }
                };
                xhr.onload = () => {
                  if (xhr.status >= 200 && xhr.status < 300) resolve(undefined);
                  else reject(new Error('Upload failed with status ' + xhr.status));
                };
                xhr.onerror = () => reject(new Error('Network error during upload'));
                xhr.send(f);
              });

              uploadProgress.style.display = 'none';
              uploadResult.style.display = 'block';
              uploadResult.textContent = `Uploaded: ${f.name}`;
              try { await el.sendCustomAction({ type: 'capture_event', payload: { kind: 'upload', key: presign.key, name: f.name, page: window.location.href } }); } catch {}
              // reset input
              try { e.target.value = ''; } catch {}
            } catch (err) {
              uploadProgress.style.display = 'none';
              alert('Upload failed: ' + (err?.message || err));
            }
          });

          // Expose for console testing
          window.chatkitOpen = openChat;
          window.chatkitClose = closeChat;
        } catch (e) {
          console.error('[chatkit-floating-test] init failed', e);
        }
      })();
    </script>
  </body>
  </html>


