<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ChatKit Minimal Test</title>
    <style>
      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji";
        background: #f8fafc;
        color: #0f172a;
      }
      /* Floating wrapper bottom-right */
      #chat-wrapper {
        position: fixed;
        bottom: 86px;
        right: 20px;
        width: 460px;
        height: 720px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        opacity: 0;
        pointer-events: none;
        transform: scale(0.95);
        transition: opacity 0.2s, transform 0.2s;
      }
      #chat-wrapper.open { 
        opacity: 1;
        pointer-events: auto;
        transform: scale(1);
      }
      #chat-wrapper > openai-chatkit {
        flex: 1 1 auto;
        width: 100%;
        height: auto;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.18);
        overflow: hidden;
        font-size: 14px;
        line-height: 1.4;
        --user-message-text-color: #ffffff;
        --font-text-md-size: 0.9rem;
        --accent-color-primary-inverse: #ffffff;
        --font-heading-lg-size: 1.3rem;
      }
      #chat-wrapper > openai-chatkit[data-accent="3"] {
        --user-message-text-color: #ffffff;
      }
      /* Round launcher button */
      #chat-launcher {
        position: fixed;
        bottom: 22px;
        right: 22px;
        width: 56px;
        height: 56px;
        border-radius: 9999px;
        background: #0f172a;
        color: #ffffff;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        box-shadow: 0 8px 24px rgba(2, 6, 23, 0.2);
        z-index: 10001;
        cursor: pointer;
      }
      #chat-launcher:hover { filter: brightness(1.05); }
    </style>
    <script
      src="https://cdn.platform.openai.com/deployments/chatkit/chatkit.js"
      async
    ></script>
    <script>
      // CES shim to block CORS errors from chatgpt.com/ces endpoints
      (function() {
        if (typeof window === "undefined" || typeof window.fetch !== "function" || window.__chatkitCesShimApplied) {
          return;
        }
        window.__chatkitCesShimApplied = true;
        const CES_PATH_PREFIX = "/ces/v1/projects/";
        const allowedHosts = ["chatgpt.com", "chatgpt-staging.com"];
        const matchesCesEndpoint = (target) => {
          if (!target) return false;
          try {
            const parsed = new URL(target, window.location.origin);
            const host = parsed.hostname.toLowerCase();
            const isChatgptHost =
              allowedHosts.some((domain) => host === domain || host.endsWith("." + domain));
            if (!isChatgptHost) return false;
            return parsed.pathname.startsWith(CES_PATH_PREFIX);
          } catch {
            return false;
          }
        };
        const responseInit = {
          status: 200,
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-store",
          },
        };
        const payload = JSON.stringify({ enabled: false });
        const originalFetch = window.fetch.bind(window);
        window.fetch = function patchedFetch(input, init) {
          try {
            const target =
              typeof input === "string"
                ? input
                : typeof Request !== "undefined" && input instanceof Request
                ? input.url
                : input && typeof input === "object"
                ? input.url
                : null;
            if (matchesCesEndpoint(target)) {
              return Promise.resolve(new Response(payload, responseInit));
            }
          } catch {
            // fall through
          }
          return originalFetch(input, init);
        };
      })();

      // Suppress console errors for CORS issues with chatgpt.com/ces
      (function() {
        if (window.__chatkitErrorSuppressionApplied) return;
        window.__chatkitErrorSuppressionApplied = true;
        
        const originalError = console.error;
        const originalWarn = console.warn;
        
        const shouldSuppress = (message) => {
          const msg = String(message || '').toLowerCase();
          return msg.includes('chatgpt.com/ces') || 
                 msg.includes('cors policy') ||
                 msg.includes('access-control-allow-origin') ||
                 (msg.includes('failed to fetch') && msg.includes('ces')) ||
                 (msg.includes('net::err_failed') && msg.includes('ces')) ||
                 msg.includes('/ces/v1/projects/');
        };
        
        console.error = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress these errors
          }
          originalError.apply(console, args);
        };
        
        console.warn = function(...args) {
          const message = args.join(' ');
          if (shouldSuppress(message)) {
            return; // Suppress these warnings
          }
          originalWarn.apply(console, args);
        };

        // Also catch unhandled promise rejections related to CES
        window.addEventListener('unhandledrejection', function(event) {
          const reason = event.reason;
          const message = reason?.message || reason?.toString() || '';
          if (shouldSuppress(message)) {
            event.preventDefault();
            return;
          }
        });
      })();
    </script>
  </head>
  <body>
    <a id="chat-launcher" href="#" aria-controls="chat-wrapper" aria-expanded="false" title="Chat">
      <svg viewBox="0 0 24 24" width="26" height="26" fill="currentColor" aria-hidden="true"><path d="M12 3C6.477 3 2 6.91 2 11.727c0 2.34 1.17 4.45 3.04 5.967-.09 1.07-.5 2.34-1.44 3.41-.22.25-.06.65.27.64 1.71-.06 3.22-.94 4.2-1.62.06-.04.13-.08.2-.12 1.1.36 2.29.56 3.53.56 5.523 0 10-3.91 10-8.727C22 6.91 17.523 3 12 3z"/></svg>
    </a>
    <div id="chat-wrapper"></div>

    <script>
      function getCaseInsensitiveParam(...candidates) {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        const keys = Array.from(params.keys());
        for (const cand of candidates) {
          const found = keys.find((k) => k.toLowerCase() === String(cand).toLowerCase());
          if (found) {
            const v = params.get(found);
            if (v) { return v.trim(); }
          }
        }
        return null;
      }

      const PROMPT_METADATA_ENDPOINT = '/api/prompt-metadata';
      const RESOLVE_TITLE_ENDPOINT = '/api/resolve-title';
      const PROMPT_STORAGE_KEY = 'chatkit_prompt_key';
      const PROMPT_STORAGE_EXPIRES_KEY = 'chatkit_prompt_key_expires';
      const PROMPT_STORAGE_HASH_KEY = 'chatkit_prompt_key_hash';
      const SECRET_STORAGE_KEY = 'chatkit_client_secret';
      const SECRET_STORAGE_EXPIRES_KEY = 'chatkit_client_secret_expires';
      const SESSION_METADATA_HASH_KEY = 'chatkit_session_metadata_hash';

      let cachedSecret = null;
      let cachedSecretExpires = 0;
      let sessionMetadataHash = null;
      let promptCache = null;

      function stableStringify(value) {
        if (value === null) return 'null';
        const type = typeof value;
        if (type === 'string') return JSON.stringify(value);
        if (type === 'number') return Number.isFinite(value) ? String(value) : 'null';
        if (type === 'boolean') return value ? 'true' : 'false';
        if (type === 'undefined' || type === 'function' || type === 'symbol') return 'null';
        if (Array.isArray(value)) {
          return '[' + value.map(stableStringify).join(',') + ']';
        }
        const entries = Object.entries(value || {})
          .filter(([, v]) => typeof v !== 'function' && typeof v !== 'symbol')
          .map(([k, v]) => [k, stableStringify(v)]);
        entries.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0));
        return '{' + entries.map(([k, v]) => JSON.stringify(k) + ':' + v).join(',') + '}';
      }

      function sanitizeMetadataValue(value) {
        if (value === null) return null;
        const type = typeof value;
        if (type === 'string' || type === 'number' || type === 'boolean') {
          return value;
        }
        if (Array.isArray(value)) {
          return value.map(sanitizeMetadataValue);
        }
        if (type === 'object') {
          return sanitizeMetadata(value);
        }
        return String(value);
      }

      function sanitizeMetadata(input) {
        if (!input || typeof input !== 'object') {
          return {};
        }
        const result = {};
        for (const [key, value] of Object.entries(input)) {
          if (!key) continue;
          result[key] = sanitizeMetadataValue(value);
        }
        return result;
      }

      function collectMetadata() {
        const params = new URLSearchParams(window.location.search || '');
        const meta = {};
        params.forEach((value, key) => {
          if (key.startsWith('meta.') || key.startsWith('meta_')) {
            const normalized = key.slice(5);
            if (normalized) {
              meta[normalized] = value;
            }
          }
        });
        return meta;
      }

      const rawMetadata = collectMetadata();
      const sanitizedMetadata = sanitizeMetadata(rawMetadata);
      const metadataHash = stableStringify(sanitizedMetadata);

      function enhanceSourceLinks(_root) {}

      const fetchingTitleSet = new Set();
      function normalizeForCompare(s) {
        return String(s || '')
          .replace(/\s+/g, ' ')
          .replace(/[.\u2014\-–—:\s]+$/g, '')
          .trim()
          .toLowerCase();
      }
      function dedupeTitleBeforeAnchor(anchor, title) {
        try {
          const prev = anchor.previousSibling;
          if (!prev || prev.nodeType !== Node.TEXT_NODE) return;
          const original = prev.textContent || '';
          const normOrig = normalizeForCompare(original);
          const normTitle = normalizeForCompare(title);
          if (normOrig.endsWith(normTitle)) {
            const idx = original.toLowerCase().lastIndexOf(title.toLowerCase());
            if (idx >= 0) {
              const trimmed = original.slice(0, idx).replace(/[.\u2014\-–—:\s]+$/g, '');
              prev.textContent = trimmed.length ? trimmed + ' ' : '';
            }
          }
        } catch(_) {}
      }
      function enhanceInlineLinks(root) {
        try {
          // Disabled: avoid altering ChatKit message content at runtime
          return;
          const anchors = root.querySelectorAll('[data-thread-turn] a[href]');
          anchors.forEach(async (a) => {
            const href = a.getAttribute('href') || '';
            if (!href || a.getAttribute('data-fyi-title-upgraded') === '1') return;
            const label = (a.textContent || '').trim();
            const looksLikeUrl = /^https?:/i.test(label) || label === href || label.includes('http');
            if (!looksLikeUrl) {
              try {
                const abs = new URL(href, window.location.origin);
                if (abs.origin !== window.location.origin) {
                  a.target = '_blank';
                  a.rel = 'noopener noreferrer';
                }
              } catch(_){}
              return;
            }
            if (fetchingTitleSet.has(href)) return;
            fetchingTitleSet.add(href);
            try {
              const res = await fetch(RESOLVE_TITLE_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: href }),
              });
              const data = await res.json().catch(() => ({}));
              const title = (typeof data?.title === 'string' && data.title.trim()) || null;
              if (title && a.isConnected) {
                a.textContent = title;
                dedupeTitleBeforeAnchor(a, title);
              }
              try {
                const abs = new URL(href, window.location.origin);
                if (abs.origin !== window.location.origin) {
                  a.target = '_blank';
                  a.rel = 'noopener noreferrer';
                }
              } catch(_){}
              a.setAttribute('data-fyi-title-upgraded', '1');
            } catch(_){
            } finally {
              fetchingTitleSet.delete(href);
            }
          });
        } catch (e) {
          console.debug('[InlineLinks] error', e);
        }
      }

      function sanitizeCitationsDeep(root) {
        try {
          // First, sanitize all text nodes
          const walker = document.createTreeWalker(
            root,
            NodeFilter.SHOW_TEXT,
            null
          );
          // More aggressive patterns to catch all variations including with special Unicode chars
          const filecitePattern = /filecite[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi;
          const turnPattern = /turn\d+file\d+/gi;
          // Also catch filecite in different contexts (with brackets, parentheses, special chars, etc.)
          const fileciteVariations = [
            /\[?filecite\]?[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi,
            /\(?filecite\)?[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi,
            /filecite[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi,
            /filecite/gi,
          ];
          let node;
          while ((node = walker.nextNode())) {
            const textNode = node;
            const original = textNode.textContent || "";
            if (!original) {
              continue;
            }
            
            // Check if text contains any citation markers
            const hasFilecite = /filecite/i.test(original);
            const hasTurnPattern = turnPattern.test(original);
            
            if (!hasFilecite && !hasTurnPattern) {
              continue;
            }
            
            turnPattern.lastIndex = 0;
            let cleaned = original;
            
            // Remove all filecite variations
            for (const pattern of fileciteVariations) {
              pattern.lastIndex = 0;
              cleaned = cleaned.replace(pattern, "");
            }
            
            // Remove turn patterns (more aggressive)
            turnPattern.lastIndex = 0;
            cleaned = cleaned.replace(turnPattern, "");
            // Also catch turn patterns with special chars
            cleaned = cleaned.replace(/turn\d+file\d+[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi, "");
            
            // Clean up extra whitespace and special characters
            cleaned = cleaned.replace(/[\u200B-\u200D\uFEFF\uE000-\uF8FF]+/g, ""); // Remove special Unicode chars
            cleaned = cleaned.replace(/\s{2,}/g, " ").trim();
            
            if (cleaned !== original.trim()) {
              textNode.textContent = cleaned;
            }
          }
          
          // Also sanitize HTML elements directly (for cases where citations are in HTML)
          const allElements = root.querySelectorAll('*');
          allElements.forEach((el) => {
            if (el.textContent && (/filecite/i.test(el.textContent) || /turn\d+file\d+/i.test(el.textContent))) {
              // Check if this element contains citations
              const originalHTML = el.innerHTML;
              if (!originalHTML) return;
              
              let cleanedHTML = originalHTML;
              // Remove filecite patterns from HTML
              cleanedHTML = cleanedHTML.replace(/filecite[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi, "");
              cleanedHTML = cleanedHTML.replace(/turn\d+file\d+[\s\u200B-\u200D\uFEFF\uE000-\uF8FF]*/gi, "");
              cleanedHTML = cleanedHTML.replace(/[\u200B-\u200D\uFEFF\uE000-\uF8FF]+/g, "");
              
              if (cleanedHTML !== originalHTML) {
                el.innerHTML = cleanedHTML;
              }
            }
          });
        } catch (error) {
          console.debug("[Citations] sanitizeCitationsDeep error", error);
        }
      }
      function storeSecret(secret, expiresAtMs) {
        cachedSecret = secret;
        cachedSecretExpires = expiresAtMs;
        sessionMetadataHash = metadataHash;
        try {
          window.localStorage.setItem(SECRET_STORAGE_KEY, secret);
          window.localStorage.setItem(SECRET_STORAGE_EXPIRES_KEY, String(expiresAtMs));
          window.localStorage.setItem(SESSION_METADATA_HASH_KEY, metadataHash);
        } catch (_) {}
      }

      function storePromptMetadata(entry) {
        promptCache = entry;
        try {
          window.localStorage.setItem(PROMPT_STORAGE_KEY, entry.key);
          window.localStorage.setItem(PROMPT_STORAGE_EXPIRES_KEY, String(entry.expiresAt));
          window.localStorage.setItem(PROMPT_STORAGE_HASH_KEY, entry.hash);
        } catch (_) {}
      }

      async function ensurePromptMetadata() {
        const now = Date.now();
        if (
          promptCache &&
          promptCache.hash === metadataHash &&
          promptCache.expiresAt > now
        ) {
          return promptCache;
        }
        try {
          const storedKey = window.localStorage.getItem(PROMPT_STORAGE_KEY);
          const storedExpires = Number(window.localStorage.getItem(PROMPT_STORAGE_EXPIRES_KEY));
          const storedHash = window.localStorage.getItem(PROMPT_STORAGE_HASH_KEY);
          if (
            storedKey &&
            storedHash === metadataHash &&
            Number.isFinite(storedExpires) &&
            storedExpires > now
          ) {
            const entry = { key: storedKey, expiresAt: storedExpires, hash: storedHash };
            storePromptMetadata(entry);
            return entry;
          }
        } catch (error) {
          console.debug('[PromptMetadata] localStorage unavailable', error);
        }
        try {
          const res = await fetch(PROMPT_METADATA_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              parameters: sanitizedMetadata,
            }),
          });
          if (!res.ok) {
            const txt = await res.text().catch(() => '');
            throw new Error(txt || res.statusText);
          }
          const data = await res.json();
          if (data && data.promptKey) {
            const entry = {
              key: data.promptKey,
              expiresAt:
                typeof data.expiresAt === 'number' && Number.isFinite(data.expiresAt)
                  ? data.expiresAt
                  : Date.now() + 5 * 60 * 1000,
              hash: metadataHash,
            };
            storePromptMetadata(entry);
            return entry;
          }
        } catch (error) {
          console.warn('[PromptMetadata] fetch failed', error);
        }
        return null;
      }

      async function getClientSecret(currentSecret) {
        const now = Date.now();

        if (currentSecret) {
          if (!cachedSecretExpires || cachedSecretExpires < now) {
            cachedSecretExpires = now + 5 * 60 * 1000;
          }
          storeSecret(currentSecret, cachedSecretExpires);
          ensurePromptMetadata().catch(() => {});
          return currentSecret;
        }

        if (
          cachedSecret &&
          cachedSecretExpires > now &&
          sessionMetadataHash === metadataHash
        ) {
          console.debug(
            '[Session] Cached secret available but ChatKit requested a new one; requesting fresh secret.'
          );
        }

        try {
          const lsSecret = window.localStorage.getItem(SECRET_STORAGE_KEY);
          const lsExpires = Number(
            window.localStorage.getItem(SECRET_STORAGE_EXPIRES_KEY)
          );
          const lsHash = window.localStorage.getItem(SESSION_METADATA_HASH_KEY);
          if (
            lsSecret &&
            Number.isFinite(lsExpires) &&
            lsExpires > now &&
            lsHash === metadataHash
          ) {
            console.debug(
              '[Session] localStorage secret available but ChatKit requested a new one; requesting fresh secret.'
            );
          }
        } catch (error) {
          console.debug('[Session] localStorage unavailable', error);
        }

        const promptEntry = await ensurePromptMetadata();

        try {
          const res = await fetch('/api/create-session', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt_parameters: sanitizedMetadata,
              ...(promptEntry
                ? {
                    prompt_metadata: {
                      key: promptEntry.key,
                      expiresAt: promptEntry.expiresAt,
                    },
                  }
                : {}),
            }),
          });
          if (!res.ok) {
            const t = await res.text().catch(() => '');
            const errorMsg =
              'Failed to create ChatKit session: ' + (t || res.statusText);
            console.error('[Session]', errorMsg);
            throw new Error(errorMsg);
          }
          const data = await res.json();
          try {
            window.appSessionId = data.app_session_id || null;
          } catch (_) {}
          if (!data || !data.client_secret) {
            const errorMsg = 'Missing client_secret in response';
            console.error('[Session]', errorMsg);
            throw new Error(errorMsg);
          }
          const expiresAtSeconds = typeof data.expires_at === 'number'
            ? data.expires_at
            : null;
          const expiresAtMs = expiresAtSeconds
            ? expiresAtSeconds * 1000
            : Date.now() + 5 * 60 * 1000;
          storeSecret(data.client_secret, expiresAtMs);

          const responsePromptKey =
            typeof data.prompt_key === 'string' ? data.prompt_key : null;
          const responsePromptExpires =
            typeof data.prompt_expires_at === 'number'
              ? data.prompt_expires_at * 1000
              : null;
          const promptKeyToPersist =
            responsePromptKey || (promptEntry && promptEntry.key) || null;
          if (promptKeyToPersist) {
            storePromptMetadata({
              key: promptKeyToPersist,
              expiresAt:
                responsePromptExpires ||
                (promptEntry && promptEntry.expiresAt) ||
                Date.now() + 5 * 60 * 1000,
              hash: metadataHash,
            });
          }

          return data.client_secret;
        } catch (error) {
          console.error('[Session] Error creating session:', error);
          throw error;
        }
      }

      (async function initWhenReady(){
        async function waitForCustomElement(name, timeoutMs = 10000) {
          if (window.customElements?.get(name)) return;
          if (window.customElements?.whenDefined) {
            await window.customElements.whenDefined(name);
            return;
          }
          await new Promise((resolve, reject) => {
            const started = Date.now();
            const poll = () => {
              if (window.customElements?.get(name)) {
                resolve();
                return;
              }
              if (Date.now() - started > timeoutMs) {
                reject(new Error(`${name} custom element not available`));
                return;
              }
              setTimeout(poll, 250);
            };
            poll();
          });
        }

        async function waitForChatKitReady(element, { timeoutMs = 20000, pollMs = 250 } = {}) {
          if (isChatKitReady(element)) {
            return element.shadowRoot;
          }
          return new Promise((resolve, reject) => {
            const started = Date.now();
            const poll = () => {
              if (isChatKitReady(element)) {
                resolve(element.shadowRoot);
                return;
              }
              if (Date.now() - started >= timeoutMs) {
                reject(new Error("ChatKit did not finish initializing"));
                return;
              }
              setTimeout(poll, pollMs);
            };
            poll();
          });
        }

        try {
          await waitForCustomElement('openai-chatkit');
        } catch (err) {
          console.error('[ChatKit] web component unavailable', err);
          return;
        }
        try {
          const wrapper = document.getElementById('chat-wrapper');
          const launcher = document.getElementById('chat-launcher');
          const firstForGreeting = getCaseInsensitiveParam('firstname','first','firstName');
          const uiGreeting = firstForGreeting ? `Hi ${firstForGreeting}, how can I help?` : 'How can I help you today?';

          // Enhancement form
          const ENH_TEXT = 'I want to request this product enhancement: ';
          const form = document.createElement('div');
          form.id = 'enh-form';
          form.style.cssText = 'display:none; position:absolute; left:8px; right:8px; bottom:8px; z-index:100; background:#ffffff; border:1px solid #e2e8f0; border-radius:10px; padding:10px; box-shadow:0 6px 16px rgba(2,6,23,.15);';
          form.innerHTML = `
            <div style="font-weight:600; color:#0f172a; margin-bottom:6px;">Enhancement request</div>
            <div style="display:grid; gap:8px;">
              <label style="display:flex; flex-direction:column; gap:4px;">
                <span style="color:#475569;">Title</span>
                <input id="enh-title" placeholder="Short, descriptive title" style="border:1px solid #cbd5e1; border-radius:6px; padding:6px;" />
              </label>
              <label style="display:flex; flex-direction:column; gap:4px;">
                <span style="color:#475569;">Description</span>
                <textarea id="enh-desc" rows="4" placeholder="What problem does this solve?" style="border:1px solid #cbd5e1; border-radius:6px; padding:6px;"></textarea>
              </label>
              <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                <label style="display:flex; flex-direction:column; gap:4px;">
                  <span style="color:#475569;">Priority</span>
                  <select id="enh-priority" style="border:1px solid #cbd5e1; border-radius:6px; padding:6px;">
                    <option>Low</option>
                    <option selected>Medium</option>
                    <option>High</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:4px;">
                  <span style="color:#475569;">Impact</span>
                  <input id="enh-impact" placeholder="Who is impacted?" style="border:1px solid #cbd5e1; border-radius:6px; padding:6px;" />
                </label>
              </div>
              <div style="display:flex; justify-content:flex-end; gap:8px;">
                <button id="enh-cancel" type="button" style="border:1px solid #cbd5e1; background:#fff; color:#0f172a; padding:6px 10px; border-radius:6px; cursor:pointer;">Cancel</button>
                <button id="enh-submit" type="button" style="background:#0f172a; color:#fff; padding:6px 10px; border:none; border-radius:6px; cursor:pointer;">Add to message</button>
              </div>
            </div>
          `;

          // Create ChatKit element dynamically (like floating test)
          const el = document.createElement('openai-chatkit');
          
          const showForm = () => { form.style.display = 'block'; };
          const hideForm = () => {
            form.style.display = 'none';
            try {
              document.getElementById('enh-title').value = '';
              document.getElementById('enh-desc').value = '';
              document.getElementById('enh-priority').value = 'Medium';
              document.getElementById('enh-impact').value = '';
            } catch(_){}
          };
          
          form.addEventListener('click', async (e) => {
            const t = e.target?.id || e.target?.closest?.('#enh-cancel, #enh-submit')?.id || '';
            if (t === 'enh-cancel') { hideForm(); return; }
            if (t === 'enh-submit') {
              try {
                const title = String(document.getElementById('enh-title')?.value || '').trim();
                const desc = String(document.getElementById('enh-desc')?.value || '').trim();
                const priority = String(document.getElementById('enh-priority')?.value || 'Medium');
                const impact = String(document.getElementById('enh-impact')?.value || '').trim();
                const lines = ['I want to request a product enhancement:'];
                if (title) lines.push(`Title: ${title}`);
                if (desc) lines.push(`Description: ${desc}`);
                if (priority) lines.push(`Priority: ${priority}`);
                if (impact) lines.push(`Impact: ${impact}`);
                const text = lines.join('\n');
                if (text) { await el.setComposerValue({ text }); }
              } catch(_) {}
              hideForm();
            }
          });

          // Set up error listener before setting options
          el.addEventListener('error', (event) => {
            console.error('[ChatKit] Element error event:', event);
          });

          el.setOptions({
            api: { getClientSecret },
            theme: {
              color: { accent: { primary: '#4ccf96', level: 3 } }
            },
            header: {
              rightAction: {
                icon: 'collapse-small',
                onClick: () => { closeChat(); }
              }
            },
            startScreen: {
              greeting: uiGreeting,
              prompts: [
                { label: "What's new with FYI?", prompt: "What's the latest with FYI?", icon: 'sparkle' },
                { label: 'Tell me about the subscription plans', prompt: 'Tell me about the subscription plans', icon: 'circle-question' }
              ]
            },
            disclaimer: { text: 'AI can make mistakes — See [ Help articles ](https://support.fyi.app/)' },
            composer: {
              placeholder: 'Message the assistant',
              attachments: {
                enabled: false,
                accept: {
                  "image/*": [".png", ".jpg", ".jpeg", ".gif", ".webp"],
                  "application/pdf": [".pdf"]
                }
              }
            },
            widgets: {
              onAction: async (action) => {
                try {
                  console.debug('[minimal] widgets.onAction', action);
                  if (action?.type === 'prefill' && action?.payload?.text) {
                    await el.setComposerValue({ text: String(action.payload.text) });
                    // focusComposer is not supported - ChatKit handles focus automatically
                    return;
                  }
                } catch(err) {
                  console.error('[minimal] widgets.onAction error:', err);
                }
              }
            }
          });

          // Monitor ChatKit initialization
          let initCheckAttempts = 0;
          let mutationObserver = null;
          const setupObserver = () => {
            const root = el.shadowRoot;
            if (root && !mutationObserver) {
              sanitizeCitationsDeep(root);
              mutationObserver = new MutationObserver(() => {
                const latestRoot = el.shadowRoot;
                if (latestRoot) {
                  sanitizeCitationsDeep(latestRoot);
                }
              });
              mutationObserver.observe(root, { childList: true, subtree: true, characterData: true });
            }
          };
          
          const checkInit = setInterval(() => {
            initCheckAttempts++;
            const root = el.shadowRoot;
            if (root) {
              setupObserver();
              sanitizeCitationsDeep(root);
              const totalElements = root.querySelectorAll('*').length;
              const hasDataKind = root.querySelectorAll('[data-kind]').length > 0;

              if (isChatKitReady(el)) {
                clearInterval(checkInit);
                return;
              }

              if (initCheckAttempts > 50 && initCheckAttempts % 20 === 0) {
                console.warn('[ChatKit] Still initializing... Attempt:', initCheckAttempts, 'totalElements:', totalElements, 'hasDataKind:', hasDataKind);
              }

              if (initCheckAttempts > 100) {
                clearInterval(checkInit);
                if (!isChatKitReady(el)) {
                  console.error('[ChatKit] Failed to initialize after 100 checks - may be in error state');
                }
              }
            }
          }, 500);

          wrapper.appendChild(el);
          wrapper.appendChild(form);

          // Wait for ChatKit to be fully initialized before injecting
          // Check if ChatKit has actual UI elements (not just loading state)
          function isChatKitReady(element) {
            const root = element.shadowRoot;
            if (!root) return false;
            
            // Check for actual UI elements - if we only have a few elements with no data-kind,
            // ChatKit is likely still loading or in an error state
            const totalElements = root.querySelectorAll('*').length;
            const hasDataKindElements = root.querySelectorAll('[data-kind]').length > 0;
            const hasComposer = root.querySelector('[data-kind="composer"], [role="textbox"], textarea, [contenteditable="true"]');
            const hasStartScreen = root.querySelector('[data-kind="start-screen"], [data-part="start-screen"]');
            
            // ChatKit is ready if:
            // 1. Has a reasonable number of elements (more than just a loading spinner)
            // 2. Has data-kind elements OR has a composer OR has a start screen
            const isReady = totalElements > 10 && (hasDataKindElements || hasComposer || hasStartScreen);
            
            // Only log if debugging is needed (commented out for production)
            // if (isReady) {
            //   console.log('[ChatKit] Ready! totalElements:', totalElements, 'hasDataKind:', hasDataKindElements, 'hasComposer:', !!hasComposer, 'hasStartScreen:', !!hasStartScreen);
            // }
            
            return isReady;
          }

          // Remove private citation markers until ChatKit exposes structured citation UI
          (function sanitizeAssistantCitations() {
            return;
          });

          // Inject dynamic response buttons for assistant questions
          (function injectResponseButtons(){
            function detectQuestion(text) {
              const trimmed = String(text || '').trim();
              
              // Check for structured response options in JSON format
              // Format: {"response_options": ["Option 1", "Option 2", "Option 3"]}
              const jsonMatch = trimmed.match(/\{"response_options":\s*\[([\s\S]*?)\]\}/);
              if (jsonMatch) {
                try {
                  const parsed = JSON.parse(jsonMatch[0]);
                  if (Array.isArray(parsed.response_options) && parsed.response_options.length > 0) {
                    return { isQuestion: true, options: parsed.response_options };
                  }
                } catch {}
              }

              // Check for markdown-style options
              // Format: - Option 1\n- Option 2\n- Option 3
              const markdownOptions = trimmed.match(/^[-•]\s*(.+)$/gm);
              if (markdownOptions && markdownOptions.length >= 2) {
                const options = markdownOptions.map(m => m.replace(/^[-•]\s*/, '').trim()).filter(Boolean);
                if (options.length >= 2) {
                  return { isQuestion: true, options };
                }
              }

              // Check for numbered options
              // Format: 1. Option 1\n2. Option 2\n3. Option 3
              const numberedOptions = trimmed.match(/^\d+\.\s*(.+)$/gm);
              if (numberedOptions && numberedOptions.length >= 2) {
                const options = numberedOptions.map(m => m.replace(/^\d+\.\s*/, '').trim()).filter(Boolean);
                if (options.length >= 2) {
                  return { isQuestion: true, options };
                }
              }

              // Check for "I can:" or "If you'd like, I can:" patterns with options separated by "or" or newlines
              const iCanPattern = /(?:If you['']d like,?\s*)?I can:?\s*([\s\S]+?)(?:\n\n|\nDid that|$)/i;
              const iCanMatch = trimmed.match(iCanPattern);
              if (iCanMatch && iCanMatch[1]) {
                const optionsText = iCanMatch[1];
                // Split by "or" (with optional semicolon), newlines, or both
                let options = optionsText
                  .split(/\s*;\s*or\s*|\s+or\s+|\n+/)
                  .map(o => o.trim())
                  .filter(o => o.length > 0 && o.length < 200 && !/^Did that/i.test(o));
                
                // If we got options, clean them up
                if (options.length >= 2) {
                  // Remove trailing punctuation and clean up
                  options = options.map(o => o.replace(/[.;,]+$/, '').trim()).filter(Boolean);
                  if (options.length >= 2) {
                    return { isQuestion: true, options };
                  }
                }
              }

              // Check for options separated by "or" in natural language
              const orPattern = /(?:Would you like|Do you want|I can|You can|Choose|Select|Pick|Options?|Choices?)[:：]?\s*([^?]+(?:\s+or\s+[^?]+)+)/i;
              const orMatch = trimmed.match(orPattern);
              if (orMatch && orMatch[1]) {
                const optionsText = orMatch[1];
                const options = optionsText
                  .split(/\s+or\s+/i)
                  .map(o => o.trim().replace(/[.;,]+$/, ''))
                  .filter(o => o.length > 0 && o.length < 200);
                if (options.length >= 2) {
                  return { isQuestion: true, options };
                }
              }

              // Simple question detection (ends with ?)
              const hasQuestionMark = /[?？]/.test(trimmed);
              if (hasQuestionMark) {
                // Try to extract options from common patterns
                const optionPatterns = [
                  /(?:Would you like|Do you want|Choose|Select|Pick)\s+(?:one of\s+)?(?:the\s+)?(?:following\s+)?(?:options\s+)?[:：]?\s*([^?]+)/i,
                  /(?:Options?|Choices?|Answers?)[:：]?\s*([^?]+)/i,
                ];
                
                for (const pattern of optionPatterns) {
                  const match = trimmed.match(pattern);
                  if (match && match[1]) {
                    const optionsText = match[1];
                    // Try to split by commas, semicolons, "or", or newlines
                    const options = optionsText
                      .split(/[,;，；]|\s+or\s+|\n+/i)
                      .map(o => o.trim().replace(/[.;,]+$/, ''))
                      .filter(o => o.length > 0 && o.length < 200);
                    if (options.length >= 2) {
                      return { isQuestion: true, options };
                    }
                  }
                }
                
                return { isQuestion: true };
              }

              // Check for questions without question marks but with options
              // Pattern: "I can:" or "If you'd like:" followed by options
              const questionWithoutMark = /(?:If you['']d like,?\s*)?(?:I can|You can|Would you like|Do you want)[:：]?\s*([\s\S]+)/i;
              const questionMatch = trimmed.match(questionWithoutMark);
              if (questionMatch && questionMatch[1]) {
                const optionsText = questionMatch[1];
                // Try splitting by "or", newlines, or semicolons
                let options = optionsText
                  .split(/\s*;\s*or\s*|\s+or\s+|\n+/i)
                  .map(o => o.trim().replace(/[.;,]+$/, ''))
                  .filter(o => o.length > 0 && o.length < 200 && !/^Did that/i.test(o));
                
                if (options.length >= 2) {
                  return { isQuestion: true, options };
                }
              }

              return { isQuestion: false };
            }

            function injectResponseButtons(messageElement, options) {
              // Check if buttons already exist
              if (messageElement.querySelector('[data-fyi-response-buttons]')) {
                return;
              }

              const buttonContainer = document.createElement('div');
              buttonContainer.setAttribute('data-fyi-response-buttons', '1');
              buttonContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(0, 0, 0, 0.1);';

              options.forEach((option) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.setAttribute('type', 'button');
                button.style.cssText = 'padding: 8px 16px; border: 1px solid #cbd5e1; border-radius: 8px; background: #ffffff; color: #0f172a; font-size: 0.875rem; cursor: pointer; transition: all 0.2s; white-space: nowrap;';
                
                button.addEventListener('mouseenter', () => {
                  button.style.background = '#f1f5f9';
                  button.style.borderColor = '#94a3b8';
                });
                
                button.addEventListener('mouseleave', () => {
                  button.style.background = '#ffffff';
                  button.style.borderColor = '#cbd5e1';
                });

                button.addEventListener('click', async (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  
                  // Disable all buttons
                  Array.from(buttonContainer.querySelectorAll('button')).forEach(btn => {
                    btn.style.opacity = '0.6';
                    btn.style.cursor = 'not-allowed';
                    btn.disabled = true;
                  });

                  try {
                    // Check if setComposerValue is available
                    if (el && typeof el.setComposerValue === 'function') {
                      await el.setComposerValue({ text: option });
                    } else {
                      // Fallback: try to find the composer and set value directly
                      const shadow = el.shadowRoot;
                      if (shadow) {
                        const composer = shadow.querySelector('[role="textbox"], [contenteditable="true"]');
                        if (composer) {
                          composer.textContent = option;
                          composer.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                      }
                    }
                    
                    // Remove buttons after a short delay
                    setTimeout(() => {
                      buttonContainer.remove();
                    }, 300);
                  } catch (error) {
                    console.error('[ResponseButtons] Failed to set composer value:', error);
                    // Re-enable buttons on error
                    Array.from(buttonContainer.querySelectorAll('button')).forEach(btn => {
                      btn.style.opacity = '1';
                      btn.style.cursor = 'pointer';
                      btn.disabled = false;
                    });
                  }
                });

                buttonContainer.appendChild(button);
              });

              // Append to the message element
              messageElement.appendChild(buttonContainer);
            }

            function processAssistantMessages(root) {
              try {
                // First, sanitize all citations in the shadow DOM
                sanitizeCitationsDeep(root);
                
                // Find all assistant messages - try multiple selectors
                let assistantMessages = root.querySelectorAll('[data-thread-turn][data-message-role="assistant"]');
                if (assistantMessages.length === 0) {
                  assistantMessages = root.querySelectorAll('[data-thread-turn][data-role="assistant"]');
                }
                if (assistantMessages.length === 0) {
                  // Try finding any thread turn that's not a user message
                  const allTurns = root.querySelectorAll('[data-thread-turn]');
                  assistantMessages = Array.from(allTurns).filter(el => {
                    const role = el.getAttribute('data-message-role') || el.getAttribute('data-role');
                    return role !== 'user' && role !== null;
                  });
                }
                
                console.log('[ResponseButtons] Found', assistantMessages.length, 'assistant messages');

                assistantMessages.forEach((messageEl, idx) => {
                  // Skip if already processed
                  if (messageEl.hasAttribute('data-fyi-processed')) {
                    console.log('[ResponseButtons] Message', idx, 'already processed');
                    return;
                  }

                  // Get message text
                  const textContent = messageEl.textContent || '';
                  console.log('[ResponseButtons] Processing message', idx, 'length:', textContent.length, 'preview:', textContent.substring(0, 100));
                  
                  // Detect question and extract options
                  const { isQuestion, options } = detectQuestion(textContent);
                  console.log('[ResponseButtons] Message', idx, 'isQuestion:', isQuestion, 'options:', options);

                  if (isQuestion && options && options.length > 0) {
                    console.log('[ResponseButtons] ✅ Detected question with options:', options);
                    // Mark as processed
                    messageEl.setAttribute('data-fyi-processed', '1');
                    
                    // Inject buttons
                    injectResponseButtons(messageEl, options);
                  } else if (isQuestion) {
                    console.log('[ResponseButtons] ⚠️ Detected question but no options extracted. Text:', textContent.substring(0, 200));
                    // Question detected but no options
                    messageEl.setAttribute('data-fyi-processed', '1');
                  } else {
                    console.log('[ResponseButtons] ❌ Not a question. Text:', textContent.substring(0, 100));
                  }
                });
              } catch (error) {
                console.error('[ResponseButtons] processAssistantMessages error', error);
              }
            }

            let responseButtonObserver = null;
            let isObserving = false;
            
            const mount = () => {
              // Try to get shadow root - don't wait for full initialization
              const root = el.shadowRoot;
              if (!root) {
                // Retry after a short delay if shadow root doesn't exist yet
                setTimeout(mount, 500);
                return;
              }

              // If already observing, don't set up again
              if (isObserving) return;
              
              try {
                responseButtonObserver?.disconnect();
              } catch {}

              // Process existing messages
              processAssistantMessages(root);

              // Observe for new messages
              responseButtonObserver = new MutationObserver(() => {
                const currentRoot = el.shadowRoot;
                if (currentRoot) {
                  processAssistantMessages(currentRoot);
                }
              });

              responseButtonObserver.observe(root, {
                childList: true,
                subtree: true,
                characterData: true,
              });
              
              isObserving = true;
              console.log('[ResponseButtons] Observer attached successfully');
            };

            // Start trying to mount immediately, retry if needed
            const startMount = () => {
              try {
                mount();
              } catch (error) {
                console.debug('[ResponseButtons] Mount attempt failed, will retry:', error);
                setTimeout(startMount, 500);
              }
            };
            
            // Start injection attempts - try immediately and retry periodically
            startMount();
            setTimeout(startMount, 1000);
            setTimeout(startMount, 2000);
          })();

          // S3 Upload injection
          let injectS3Button;
          (function injectS3Upload(){
            const PROGRESS_HTML = `
              <div id="s3-progress" style="display:none; position:absolute; left:12px; right:12px; bottom:56px; z-index:101;">
                <div style="height:6px; background:#e5e7eb; border-radius:9999px; overflow:hidden;">
                  <div id="s3-bar" style="width:0%; height:6px; background:#4ccf96;"></div>
                </div>
                <div id="s3-text" style="font-size:12px; color:#64748b; margin-top:4px;">0%</div>
              </div>`;
            
            const mount = async () => {
              let root;
              try {
                root = await waitForChatKitReady(el, { timeoutMs: 20000, pollMs: 250 });
              } catch (readyError) {
                console.warn('[S3] Skipping injection - ChatKit never became ready', readyError);
                return;
              }

              // Try multiple selectors for composer
              let composer = root.querySelector('[data-kind="composer"]');
              if (!composer) composer = root.querySelector('[role="textbox"]');
              if (!composer) composer = root.querySelector('textarea, [contenteditable="true"]');
              if (!composer) {
                // Find a composer-like container
                composer = Array.from(root.querySelectorAll('*')).find(el => {
                  const text = el.textContent || '';
                  return text.includes('Message') || text.includes('Type');
                })?.closest('[data-kind]') || null;
              }
              if (!composer) {
                console.warn('[S3] ChatKit ready but composer not found - aborting custom inject');
                return;
              }
              if (composer.querySelector('[data-fyi-plus]')) {
                console.log('[S3] Button already exists');
                return;
              }

              if (!document.getElementById('s3-progress')) {
                wrapper.insertAdjacentHTML('beforeend', PROGRESS_HTML);
              }

              if (composer.style.position === 'static' || !composer.style.position) {
                composer.style.position = 'relative';
              }

              let input = document.getElementById('fyi-file');
              if (!input) {
                input = document.createElement('input');
                input.type = 'file';
                input.id = 'fyi-file';
                input.accept = 'image/*,application/pdf';
                input.style.display = 'none';
                wrapper.appendChild(input);
              }

              const plus = document.createElement('button');
              plus.setAttribute('data-fyi-plus', '1');
              plus.type = 'button';
              plus.title = 'Attach file';
              plus.textContent = '+';
              plus.style.cssText = 'position:absolute; right:8px; bottom:8px; width:32px; height:32px; border-radius:9999px; border:1px solid #cbd5e1; background:#4ccf96; color:#0f172a; font-weight:700; line-height:1; display:inline-flex; align-items:center; justify-content:center; cursor:pointer; z-index:999;';
              composer.appendChild(plus);
              console.log('[S3] Upload button injected successfully!');

              plus.addEventListener('click', () => input?.click());
              input.addEventListener('change', async (e) => {
                const f = e.target?.files?.[0];
                if (!f) return;
                const appSessionId = window.appSessionId;
                if (!appSessionId) { alert('Upload unavailable'); return; }
                
                const progress = document.getElementById('s3-progress');
                const bar = document.getElementById('s3-bar');
                const text = document.getElementById('s3-text');
                if (progress) progress.style.display = 'block';

                try {
                  const presignRes = await fetch('/api/attachments/presign', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ appSessionId, filename: f.name, mime: f.type || 'application/octet-stream', size: f.size })
                  });
                  const presign = await presignRes.json();
                  if (!presignRes.ok) throw new Error(presign?.error || 'presign failed');

                  await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('PUT', presign.url, true);
                    xhr.setRequestHeader('Content-Type', f.type || 'application/octet-stream');
                    xhr.setRequestHeader('x-amz-server-side-encryption', 'AES256');
                    xhr.upload.onprogress = (ev) => {
                      if (ev.lengthComputable && bar && text) {
                        const pct = Math.round((ev.loaded / ev.total) * 100);
                        bar.style.width = pct + '%';
                        text.textContent = pct + '%';
                      }
                    };
                    xhr.onload = () => xhr.status >= 200 && xhr.status < 300 ? resolve() : reject(new Error('Upload failed: ' + xhr.status));
                    xhr.onerror = () => reject(new Error('Network error'));
                    xhr.send(f);
                  });

                  if (progress) progress.style.display = 'none';
                  if (el.sendCustomAction) {
                    await el.sendCustomAction({ type: 'upload', payload: { name: f.name, key: presign.key } });
                  }
                  e.target.value = '';
                } catch (err) {
                  if (progress) progress.style.display = 'none';
                  alert('Upload failed: ' + (err?.message || err));
                }
              });
            };
            injectS3Button = mount;
            // Start injection after ChatKit reports ready
            setTimeout(mount, 500);
          })();

          // Inject custom prompts (Enhancement request, Report an issue)
          (function injectCustomPrompts(){
            const prompts = [
              { label: 'Enhancement request', icon: 'sparkle', action: () => showForm() },
              { label: 'Report an issue', icon: 'bug', action: async () => {
                await el.setComposerValue({ text: 'I want to report the following issue: ' });
                // focusComposer is not supported - ChatKit handles focus automatically
              }}
            ];
            
            const sparkleIcon = `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor"><path d="M8 0c.552 0 1 .448 1 1v1c0 .552-.448 1-1 1s-1-.448-1-1V1c0-.552.448-1 1-1zm0 13c.552 0 1 .448 1 1v1c0 .552-.448 1-1 1s-1-.448-1-1v-1c0-.552.448-1 1-1zM3.05 3.05c.39-.39 1.024-.39 1.414 0l.707.707c.39.39.39 1.024 0 1.414-.39.39-1.024.39-1.414 0l-.707-.707c-.39-.39-.39-1.024 0-1.414zm8.9 8.9c.39-.39 1.024-.39 1.414 0l.707.707c.39.39.39 1.024 0 1.414-.39.39-1.024.39-1.414 0l-.707-.707c-.39-.39-.39-1.024 0-1.414zM0 8c0-.552.448-1 1-1h1c.552 0 1 .448 1 1s-.448 1-1 1H1c-.552 0-1-.448-1-1zm13 0c0-.552.448-1 1-1h1c.552 0 1 .448 1 1s-.448 1-1 1h-1c-.552 0-1-.448-1-1zM3.05 12.95c.39.39.39 1.024 0 1.414l-.707.707c-.39.39-1.024.39-1.414 0-.39-.39-.39-1.024 0-1.414l.707-.707c.39-.39 1.024-.39 1.414 0zm8.9-8.9c.39.39.39 1.024 0 1.414l-.707.707c-.39.39-1.024.39-1.414 0-.39-.39-.39-1.024 0-1.414l.707-.707c.39-.39 1.024-.39 1.414 0z"/></svg>`;
            const bugIcon = `<svg viewBox="0 0 16 16" width="16" height="16" fill="currentColor"><path d="M3.825 9h-.65a.175.175 0 0 1-.175-.175v-.35a.175.175 0 0 1 .175-.175h.65V6.337C3.825 5.416 4.617 4.625 5.538 4.625h.962V3.55h-.65a.175.175 0 0 1-.175-.175v-.35a.175.175 0 0 1 .175-.175h.65V1.175c0-.097.079-.175.175-.175h2.65c.096 0 .175.078.175.175V2.85h.65a.175.175 0 0 1 .175.175v.35a.175.175 0 0 1-.175.175h-.65v1.075h.962c.92 0 1.713.791 1.713 1.712V8.3h.65a.175.175 0 0 1 .175.175v.35a.175.175 0 0 1-.175.175h-.65v1.35c0 .92-.792 1.712-1.713 1.712h-.962v1.788c0 .096-.078.175-.175.175h-2.65a.175.175 0 0 1-.175-.175v-1.788h-.962A1.728 1.728 0 0 1 3.825 10.35V9z"/></svg>`;
            const rightArrow = `<svg viewBox="0 0 20 20" width="14" height="14" fill="currentColor"><path d="M7.21 14.77a.75.75 0 0 1 .02-1.06L10.06 11 7.23 8.29a.75.75 0 0 1 1.04-1.08l3.5 3.25a.75.75 0 0 1 0 1.08l-3.5 3.25a.75.75 0 0 1-1.06-.02z"/></svg>`;
            
            const inject = async () => {
              let root;
              try {
                root = await waitForChatKitReady(el, { timeoutMs: 20000, pollMs: 250 });
              } catch (readyError) {
                console.warn('[CustomPrompts] Skipping injection - ChatKit never became ready', readyError);
                return;
              }

              // Find the start screen prompts container
              const startScreen = root.querySelector('[data-kind="start-screen"], [data-part="start-screen"]');
              if (!startScreen) {
                console.warn('[CustomPrompts] Start screen not found – skipping');
                return;
              }
              
              // Find the prompts list
              const promptsList = startScreen.querySelector('[role="list"], .prompts-list, [data-prompts]') || 
                                  Array.from(startScreen.querySelectorAll('*')).find(el => el.children.length >= 2 && 
                                    Array.from(el.children).every(c => c.tagName === 'BUTTON'));
              
              if (!promptsList) {
                console.log('[CustomPrompts] Start screen found but no prompts list - skipping injection');
                return;
              }
              
              // Check if already injected
              if (promptsList.querySelector('[data-fyi-custom-prompt]')) {
                console.log('[CustomPrompts] Already injected');
                return;
              }
              
              // Get a sample native button for styling
              const sampleBtn = promptsList.querySelector('button');
              if (!sampleBtn) {
                console.log('[CustomPrompts] Prompts list found but no native buttons - skipping injection');
                return;
              }
              
              console.log('[CustomPrompts] Injecting custom prompts');
              
              prompts.forEach(({ label, icon, action }) => {
                const btn = sampleBtn.cloneNode(true);
                btn.setAttribute('data-fyi-custom-prompt', '1');
                
                // Update the text content
                const labelSpan = btn.querySelector('[data-part*="label"], .label, span:last-of-type');
                if (labelSpan) labelSpan.textContent = label;
                
                // Update the icon
                const iconSpan = btn.querySelector('[data-part*="icon"], .icon, span:first-of-type');
                if (iconSpan) {
                  iconSpan.innerHTML = icon === 'bug' ? bugIcon : sparkleIcon;
                }
                
                // Wire up the action
                btn.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  action();
                });
                
                promptsList.appendChild(btn);
              });
              
              console.log('[CustomPrompts] Injection complete');
            };
            
            // Start injection attempts after a short delay
            setTimeout(inject, 750);
          })();

          // Force white user text
          (function forceWhiteText(){
            const apply = async () => {
              let root;
              try {
                root = await waitForChatKitReady(el, { timeoutMs: 10000, pollMs: 250 });
              } catch {
                return;
              }
              if (!root || root.querySelector('style[data-fyi-white]')) return;
              const style = document.createElement('style');
              style.setAttribute('data-fyi-white', '1');
              style.textContent = `
                [data-message-role="user"],
                [data-role="user"] {
                  --user-message-text-color: #ffffff !important;
                  color: #ffffff !important;
                }
                [data-message-role="user"] *,
                [data-role="user"] * {
                  color: #ffffff !important;
                }
              `;
              root.appendChild(style);
            };
            apply();
          })();

          // Hide internal header
          (function hideHeader(){
            const hide = async () => {
              let root;
              try {
                root = await waitForChatKitReady(el, { timeoutMs: 10000, pollMs: 250 });
              } catch {
                return;
              }
              const headers = root.querySelectorAll('[part*="header"], [data-kind="header"], header');
              headers.forEach((h) => {
                Array.from(h.children).forEach((c) => {
                  const isAction = (c.getAttribute('part') || '').includes('rightAction') || c.getAttribute('aria-label');
                  if (!isAction) c.style.display = 'none';
                });
                h.style.background = 'transparent';
                h.style.border = 'none';
              });
            };
            hide();
          })();

          // Prevent native uploads
          el.addEventListener('drop', (ev) => { ev.preventDefault(); ev.stopPropagation(); }, true);
          el.addEventListener('paste', (ev) => {
            const items = ev.clipboardData?.items ? Array.from(ev.clipboardData.items) : [];
            if (items.some((it) => it?.kind === 'file')) {
              ev.preventDefault();
              ev.stopPropagation();
            }
          }, true);

          // Hide native attach button
          (function hideNativeAttach(){
            const hide = async () => {
              let root;
              try {
                root = await waitForChatKitReady(el, { timeoutMs: 10000, pollMs: 250 });
              } catch {
                return;
              }
              if (root.querySelector('style[data-fyi-hide]')) return;
              const s = document.createElement('style');
              s.setAttribute('data-fyi-hide', '1');
              s.textContent = `[data-kind="composer"] [aria-label*="Attach" i], [data-kind="composer"] [part*="attach" i] { display: none !important; }`;
              root.appendChild(s);
            };
            hide();
          })();

          function openChat() {
            console.log('[minimal] openChat called');
            wrapper.classList.add('open');
            launcher.setAttribute('aria-expanded', 'true');
            // ChatKit handles focus automatically when opened
          }

          function closeChat() {
            wrapper.classList.remove('open');
            launcher.setAttribute('aria-expanded', 'false');
          }

          launcher.addEventListener('click', (e) => {
            e.preventDefault();
            wrapper.classList.contains('open') ? closeChat() : openChat();
          });

        } catch (e) {
          console.error('[minimal-test] init failed', e);
        }
      })();
    </script>
  </body>
</html>
